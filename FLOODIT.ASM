;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FLOOD-IT FOR TRS-80 COCO MODEL 2
;EVAN C. WRIGHT, 2016
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KBSCAN 	EQU $A1CB
LAST_LINE EQU (1024+480) 
TURNS_COORD EQU (1024+487)
VRAM_END EQU (1024+512)
LINE_ONE_END EQU (1024+32)
TOP_SQUARE EQU (1024+40)
SND_REPEAT_COUNT EQU $3F00
;	SND_DELAY EQU $3F02
SND_START_ADDR EQU $3F03
SND_END_ADDR EQU $3F05

	INCLUDE KEYS.ASM
	INCLUDE SNDDEFS.ASM

GREEN EQU 96
DARK_GREEN EQU 32
BLACK EQU 128
WHITE EQU 207
YELLOW EQU 159
BLUE EQU 175
CYAN EQU 223
RED EQU 191
ORANGE EQU 255
MAGENTA EQU 247
VRAM EQU 1024
MAX_TURNS EQU 50

	ORG 0x0E00 ; START CODE HERE
START 
	LDU #0x7FFF ; setup user stack
	CLR TURNS	; SET TURNS TO 0	
	LDA #0			;CLEAR PREVIOUS QUIT_FLAG
	STA QUIT_FLAG
	;COPY THE INTRO TO SCREEN MEMORY
	LDY #SCREEN_BUFFER_2
	JSR SWITCH_BUFFERS
	JSR FILL_INTRO
	;WAIT FOR SPACEBAR
@sp	JSR KBSCAN  ; PUTS KEYCODE INTO A - 0 = NO KEY
	CMPA #0
	BEQ @sp
	CMPA #KEY_SPACE
	BNE @sp
	;START GAME
	JSR CREATE_BOARD
	JSR DRAW_LEGEND
KB_LOOP:
	JSR KBSCAN  ; PUTS KEYCODE INTO A - 0 = NO KEY
	CMPA 0	
	BEQ KB_LOOP	; IF 0 (NO KEY), REPEAT LOOP
	;KEY WAS PRESSED
	CMPA #KEY_ESC
	BEQ DONE
	CMPA #KEY_H
	BNE @a
	LDY #SCREEN_BUFFER
	JSR SWITCH_BUFFERS
	BRA KB_LOOP
@a	CMPA #KEY_B
	BNE @b
	LDA #BLUE
	STA NEW_COLOR	; B KEY 
	JSR START_FILL
	BRA KB_LOOP
@b	CMPA #KEY_Y		; Y KEY - YELLOW
	BNE @c
	LDA #YELLOW
	STA NEW_COLOR	
	JSR START_FILL
	BRA KB_LOOP
@c	CMPA #KEY_W		; W KEY - WHITE
	BNE @d
	LDA #WHITE
	STA NEW_COLOR
	JSR START_FILL
	BRA KB_LOOP
@d	CMPA #KEY_R		; R RED
	BNE @e
	LDA #RED
	STA NEW_COLOR	; R KEY 
	JSR START_FILL
	JMP KB_LOOP
@e	CMPA #KEY_G		; G KEY 
	BNE @f
	LDA #GREEN
	STA NEW_COLOR	
	JSR START_FILL
	JMP KB_LOOP	
@f	CMPA #KEY_C		  
	BNE @g
	LDA #CYAN
	STA NEW_COLOR	
	JSR START_FILL
@g	JMP KB_LOOP
DONE:	
	LDA #GREEN
	STA CLR_COLOR
	LDX #VRAM
	JSR CLS
	RTS ; return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOOP TO FILL THE SCREEN WITH RANDOM COLOR CODES
; REGISTERS ARE CLOBBERED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CREATE_BOARD:
	LDA #0
	STA TURNS
	LDA #BLACK
	STA CLR_COLOR
	LDX #VRAM
	JSR CLS
	LDD #0		; loop counter
	LDY #(1024+39)	; load addr to copy to

@ot PSHS A		; save A (loop counter)
	;DO INNER
	LDB #0
@in	PSHS B
	JSR RND5	;GET RND COLOR
	LDX NEXTFIB-1
	LDA COLORS,X
	STA ,Y+	; copy char to location stored in Y increment Y
	PULS B
	INCB
	CMPB #16
	BNE @in
	LEAY 16,Y ;BUMP Y TO NEXT ROW
	;END INNER
	PULS A
	INCA
	CMPA #14
	BNE @ot	
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE NEXT FIBONACCI NUMBER IN A AND NEXTFIB
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RND5:
	PSHS A
	;COMPUTE NEXT
	LDA FIB1
	ADDA FIB2
	STA NEXTFIB
	;SHIFT 2 INTO 1
	LDA FIB2
	STA FIB1
	;SHIFT NEW INTO 2
	LDA NEXTFIB
	STA FIB2
	;MASK OF LEFT BITS
;	ANDA RNDMASK
	CMPA #0
	BGE MODLOOP
	NEGA	; flip to pos
MODLOOP:
	CMPA #6
	BMI RNDDONE
	SUBA #6 ; SUBTRACT 5 OFF TO PUT NUMBER IN RANGE
	BRA MODLOOP
RNDDONE:
	STA NEXTFIB	
	PULS A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAW_LEGEND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DRAW_LEGEND:
	LDX #LEGEND
	LDY #LAST_LINE
	JSR STRCPY
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REGISTERS GET CLOBBERED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FILL_INTRO:
	LDY  #(VRAM+32)
@lp LDA ,Y			; LOAD SCREEN BYTE
	CMPA #0x8F		; GREEN?
	BEQ @pl	
	LDA #BLUE		; YES, MAKE IT BLUE
	STA ,Y
@pl LEAY 1,Y		;INC Y	
	JSR WASTE_TIME
	JSR WASTE_TIME		
	JSR WASTE_TIME	
	CMPY #1376	;DONE (just below title on screen)
	BNE @lp
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CLS
;CLEARS SCREEN WITH COLOR STORED IN CLR_COLOR
;X CONTANS ADDR TO CLEAR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLS:
	PSHS D,X,Y  ; SAVE REGISTERS
	LDY #0
@a	LDA CLR_COLOR 	
 	STA ,X+
	LDA	,Y+
	CMPY #512  ; bottom of screen mem
	BNE @a
	PULS Y,X,D  ; RESTORE REGISTERS
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;START_FILL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START_FILL:
	INC TURNS
	LDA TURNS
	LDX #TURNS_COORD
	JSR ATOI
	JSR CLEAR_FLAGS
	;SAVE THE ORIGNAL COLOR
	LDA VRAM+39
	STA OLD_COLOR
	;MAKE 0,0 THE NEW COLOR
	LDA #7
	PSHU A	; X
	LDA #1
	PSHU A	; Y
	JSR BUCKET_FILL
	JSR CHECK_WIN
	PULU A 	; GET RETURN CODE
	CMPA #1	; 1 IS A WIN
	BNE @no
	JSR PLAY_WIN_MUSIC
	JSR WAIT_ANY_KEY
	BRA @x
@no	LDA TURNS			; CHECK THE TURN
	CMPA #25			;
	BNE @x				; STILL PLAYING
	JSR SHOW_LOSE_MESSAGE
	JSR WAIT_ANY_KEY
@x	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BUCKET_FILL
;IF SQUARE IS INBOUNDS AND NOT MARKED AND
;COLOR OF SQUARE IS EQUAL TO OLD COLOR,
;MAKE IT THE NEW COLOR AND BUCKET FILL THE
;SUROUNDING SQUARES
;THE X,Y COORD OF THE SQUARE TO FILL IS 
;PASSED ON THE USER STACK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BUCKET_FILL:
	;GET THE SQUARE TO CLEAR
	PULU B 
	STA Y_COORD
	PULU A
	STA X_COORD
	;SEE IF X IS ON THE BOARD	
	CMPA #6		; 	LEFT EDGE
	LBEQ @x
	CMPA #24	; OFF RIGHT EDGE	
	LBEQ @x
	;VERIFY Y (WHICH IS IN B)
	CMPB #0		; TOP ROW
	BEQ @x		;OFF TOP
	CMPB #15	; BOTTOM ROW
	BEQ @x		;OFF BOTTOM
	;SEE IF IT'S BEEN MARKED ALREADY
	;(COMPUTE OFFSET = Y*32+X)
	LDA #32
	MUL		; D = Y * 32
	ADDB X_COORD	
	BCC @nc	; NO CARRY
	INCA	; ADD CARRY TO A
	;D NOW CONTAINS THE OFFSET OF THE FLAG
@nc	TFR D,X
	LDA FLAGS,X
	CMPA #1	; ALREADY MARKED?
	BEQ @x	; BAIL IF ALREADY MARKED
	;IS THE COLOR OF THIS SQUARE EQUAL TO THE OLD_COLOR?
	LDA VRAM,X
	CMPA OLD_COLOR
	BNE @x
	;MAKE IT THE NEW COLOR
	LDA NEW_COLOR
	STA VRAM,X
	;MARK THE SQUARE
	LDA #1
	STA FLAGS,X  ;AFTER THIS, DONE WITH OFFSET
	;BUCKET FILL THE FOUR SURROUNDING SQUARES
	; FILL RIGHT (X+1,Y)
	JSR SAVEXY
	LDA X_COORD
	INCA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL	
	JSR RESTOREXY
	; FILL LEFT (X-1,Y)
	JSR SAVEXY
	LDA X_COORD
	DECA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL 
	JSR RESTOREXY
	; FILL UP  (X,Y-1)
	JSR SAVEXY
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	DECA 
	PSHU A
	JSR BUCKET_FILL
	JSR RESTOREXY
	; FILL DOWN (X,Y+1)
	JSR SAVEXY
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	INCA 
	PSHU A
	JSR BUCKET_FILL	
	JSR RESTOREXY
@x	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CLEAR_FLAGS
; SETS EACH OF THE 60 FLAG BYTES TO 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLEAR_FLAGS:
	LDY #0		;loop counter
	LDX #FLAGS	;start addr
@a	LDA 0
	STA ,X+ 	;clear the byte
	LDA ,Y+		;inc loop counter (clobbers a)
	CMPY #480
	BNE @a
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CHECK WIN
;SCAN THE SCREEN MEMORY LOOKING FOR A CHAR THAT
;DOESN'T MATCH THE FIRST.  THE RESULT (0 or 1)
;IS RETURNED ON THE USER STACK.
;REGISTERS ARE NOT AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_WIN:
	PSHS D,X,Y
	LDY #0		; LOOP COUNTER
	LDX #VRAM	;	ADDRESS OF VIDEO RAM (START OF COMPARISON)
	LDA VRAM+39	;	LOAD 1ST CHAR OF VRAM
	STA TEMP	;	SAVE 1ST CHAR IN TEMP	
@lp	LDA ,X+		;	GET CHAR FROM SCREEN_MEM
	CMPA #BLACK	; 	SKIP BLACK (PART OF BACKGROUND)
	BEQ @sk		; 
	CMPA TEMP	;	DOES IT MATCH THE 1ST CHAR
	BNE @no 	;	FOUND A CHAR THAT DIDN'T MATCH THE FIRST
@sk	LEAY 1,Y		;	INC LP COUNTER
	CMPY #479	;	HIT END?
	BNE @lp		;	LOOP
	LDA #1		;	IF GOT HERE, LOOP DONE, ALL CHARS ON SCRN ARE THE SAME		
	BRA @r	;	DONE
@no	LDA #0	; 0 = NOT FOUND
@r	PSHU A
	PULS Y,X,D
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SWITCH_BUFFERS
; THIS ROUTINE COPIES THE SCREEN MEMORY INTO
; THE GRAPHICS BUFFER IN REGISTER Y.
;
; THE SRC IS ASSUMED TO BE THE SCREEN MEMORY
; Y CONTAINS ADDRESS OF OFFSCREEN BUFFER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SWITCH_BUFFERS:
	PSHS A,X
	LDX #VRAM
@a	LDA ,X		;SAVE SCREEN BYTE
	STA TEMP
	LDA ,Y		;LOAD BUFFER BYTE
	STA ,X		;COPY BUFFER BYTE TO SCREEN
	LDA TEMP	;GET SCREEN BYTE BACK
	STA ,Y		;COPY SCREEN TO BUF
	LDA ,X+ ; INC X
	LDA ,Y+ ; INC Y
	CMPX #VRAM_END ; DONE?
	BNE @a
	PULS X,A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SAVEXY
;PUTS X_COORD AND Y_COORD ON THE USER STACK
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SAVEXY:
	PSHS A
	LDA X_COORD
	PSHU A
	LDA Y_COORD
	PSHU A
	PULS A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTOREXY
;PULS X_COORD AND Y_COORD OFF THE USER STACK
;AND BACK INTO THEIR MEMORY LOCATIONS
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESTOREXY:
	PSHS A
	PULU A
	STA Y_COORD
	PULU A
	LDA X_COORD
	PULS A
	RTS	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HANDLE_GAME_OVER
;CALLED WHEN THE PLAYER WINS OR LOSES
;WAITS FOR ANY KEY AND SETS THE QUIT FLAG
;IF NEEDED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HANDLE_GAME_OVER:
	JSR WAIT_ANY_KEY
	LDA QUIT_FLAG
	CMPA #1
	BEQ @x
	JSR CREATE_BOARD	
@x	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE GAME OVER MESSAGE ON THE SCREEN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SHOW_LOSE_MESSAGE:
	LDX #GAME_OVER_LINE_1
	LDY #(1034+256)
	JSR STRCPY
	
	LDX #GAME_OVER_LINE_2
	LDY #(1034+256+32)
	JSR	STRCPY
	
	LDX #GAME_OVER_LINE_1
	LDY #(1034+256+64)
	JSR STRCPY
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	WASTE TIME
;	AN EMPTY LOOP TO WASTE TIME.  USED FOR
;	THE BLINKING WHEN THE PLAYER WINS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WASTE_TIME:
	PSHS A
	LDA #0xFF
@lp	DECA	
	CMPA #0
	BNE @lp
	PULS A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; STRCPY:
; SRC AND DEST NEED TO BE STORED IN X,Y
; REGISTERS ARE PRESERVED.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
STRCPY:
	PSHS D,X,Y
@a	LDA ,X+
	CMPA 0
	BEQ @x
	STA ,Y+
	BRA @a
@x	PULS Y,X,D
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAWS AN 8 BsIT NUMBER TO THE SCREEN
;ONLY WORKS FOR POSITIVE NUMBERS
;A CONTAINS NUMBER
;X CONTAINS RIGHT EDGE OF SCREEN LOCATION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ATOI:
@lp	JSR A_DIV_10	;DIVIDE BY 10, REMAINDER IN B
	ADDB #48		;CONVERT B TO CHAR CODE (NUMBERS START AT 48)
	STB	,X			;DRAW TO SCREEN
	LEAX -1,X		;SHIFT LEFT ON SCREEN
	CMPA #0			;DONE?
	BNE @lp
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DIVIDES A BY TEN AND PUTS THE REMAINDER IN B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
A_DIV_10:
	LDB #0
@lp CMPA #10
	BLT @x		; 10 WON'T GO IN, DONE
	SUBA #10 	; SUBTRACT 10
	INCB		
	BRA @lp		
@x	
	EXG	B,A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;WAITS UNTIL A KEY IS PRESSED.
;IF THE KEY WAS ESC, THE QUIT_FLAG IS SET TO 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_ANY_KEY
@l	JSR KBSCAN  ; PUTS KEYCODE INTO A - 0 = NO KEY
	CMPA 0
	BEQ @l
	CMPA KEY_ESC
	BNE @x
	LDA #1
	STA QUIT_FLAG	
@x	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;REGISTERS ARE PRESERVED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
PLAY_WIN_MUSIC
	LDA #3
@lp	PSHS D,X,Y
	LDY	#55		;LENGTH (0.125 x 440HZ)
	LDA #135		;A
	STA FREQ
	JSR SOUND_PLAY
	LDY	#73		;LENGTH (0.125 x 587)
	LDA #100		;D
	STA FREQ
	JSR SOUND_PLAY
	LDY	#110		;LENGTH (0.125 x  749)
	LDA #78		;F#
	STA FREQ
	JSR SOUND_PLAY	
	PULS D,X,Y
	DECA
	CMPA #0
	BNE @lp
	RTS	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PLAYS A TONE WHOSE INFO IS STORED IN THE 
;SND DATA STRUCTURE
; Y CONTAINS THE NUMBER OF TIMES TO LOOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SOUND_PLAY
	;SETUP SND
	LDA PIA_CTRL1
	ANDA #$F7		;RESET MUX BIT (WHY?)
	STA PIA_CTRL1	; (SOUND TO SPKR?)
	LDA PIA_CTRL2	
	ANDA #$F7
	STA PIA_CTRL2 ; (SOUND ON?)
	LDA PIA_SND_ENABLE
	ORA #8			; GET BIT 6
	STA PIA_SND_ENABLE
	;MAIN SOUND LOOP - THE DELAY WHICH 
	;CONTROLS THE 
	;LDY SND_DATA	; LOAD REPEAT COUNT (NOW SUPPLIED BY CALLER)
@o	LDX	SND_DATA+3	; LOAD START ADDR
@i	LDA ,X+			; GET NEXT BYTE
	ANDA #$FC		; RESET 2 LS BITS
	STA	PIA_DATA
	JSR SND_DELAY	; USE DELAY TO CONTROL FREQ
	CMPX SND_DATA+5	; TEST FOR END ADDR
	BNE @i			; KEEP GOING
	LEAY -1,Y		; DEC MAIN LP COUNTR (SETS Z FLAG)
	BNE @o			; START OVER AT BEGINNING OF SOUND DATA
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	WASTE TIME
;	AN EMPTY LOOP TO WASTE TIME. 
;	THIS ROUTINE WILL GET CALLED 4 TIMES
;	PER SINE WAVE CYCLE.
;
;	CYCLES: 14 + 11 TIME THROUGH THE LOOP
;	25 CYCLES = 35,600 HZ
;	
;	@440HZ EACH CYCLE NEEDS TO TAKE .0022 seconds
;	THAT MEANS 4 LOOPS OF .00056 SECS
;	TO MAKE EACH DELAY TAKE .00056 SECONDS
;	THE LOOP COUNT NEEDS TO BE 500 cycles long
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SND_DELAY:
	PSHS A		; 4
	LDA	FREQ	; 5
@lp	DECA		; 2
	CMPA #0		; 2
	BNE @lp		; 3
	PULS A		; 4
	RTS			; 5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
; program data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
QUIT_FLAG	.db  0x00
;	COLOR CODE ARRAY
COLORS:
	.db GREEN	; DARK GREEN
	.db CYAN
	.db WHITE
	.db BLUE 
	.db YELLOW 
	.db RED
;	RANDOM NUMBER STUFF
FIB1:		
	.db 1 ; 55
FIB2:
	.db 1 ; 89
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
NEXTFIB:	
	.db 1 
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
OLD_COLOR .db 0	;	ORIGINAL COLOR OF 0,0 BEFORE BUCKET FILL
NEW_COLOR .db 0	;	COLOR TO BUCKET FILL WITH
CLR_COLOR .db 32	
TURNS .db 0	;
TEMP	.db 0
TEMP_WORD .dw 0
X_COORD .db 0
Y_COORD .db 0
LEGEND:	
	.STRZ "MOVES   /25   H=HELP  BREAK=QUIT"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	MARKED_FLAGS: WHERE EACH SQUARE HAS BEEN MARKED
;   BY THE FLOOD FILL ALGORITHM.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAGS .RS 480	;
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HELP SCREEN BUFFER.  THIS SECTION CONTAINS
;16 LINES OF 32 CHARACTERS.  WHEN THE HELP SCREEN IS
;DISPLAYED THE CONTENTS OF THIS MEMORY AND THE VRAM
;WILL BE SWITCHED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
SCREEN_BUFFER:
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,73,78,83,84,82,85,67,84,73,79,78,83,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,84,82,89,143,84,79,143,77,65,75,69,143,84,72,69,143,66,79,65,82,68,143,65,76,76,143,84,72,69,143
	.DB 143,143,83,65,77,69,143,67,79,76,79,82,143,66,89,143,66,85,67,75,69,84,143,70,73,76,76,73,78,71,143,143
	.DB 143,143,84,72,69,143,84,79,80,44,76,69,70,84,46,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,66,143,66,76,85,69,143,143,143,143,89,143,89,69,76,76,79,87,143,87,143,87,72,73,84,69,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,88,143,66,76,65,67,75,143,143,143,89,143,89,143,76,76,79,87,143,143,143,143,143,46,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,80,82,69,83,83,143,83,80,65,67,69,143,84,79,143,82,69,84,85,82,78,143,84,79,143,71,65,77,69,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
SCREEN_BUFFER_2: ;	INTRO SCREEN
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,128,191,175,143,175,143,143,175,128,159,143,128,207,159,143,175,207,143,143,143,207,128,191,143,175,128,159,143,175,143
	.DB 143,143,207,143,143,143,159,143,143,191,143,128,143,159,143,191,143,128,143,175,143,143,143,159,143,143,143,191,143,143,159,143
	.DB 143,143,159,191,143,143,191,143,143,207,143,175,143,191,143,128,143,207,143,191,143,143,143,191,143,143,143,159,143,143,191,143
	.DB 143,143,207,143,143,143,175,143,143,175,143,191,143,207,143,191,143,159,143,207,143,143,143,207,143,143,143,207,143,143,143,143
	.DB 143,143,128,143,143,143,207,159,143,191,207,175,143,128,175,159,143,191,175,143,143,143,207,159,128,143,143,191,143,143,128,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,67,79,67,79,143,86,69,82,83,73,79,78,143,66,89,143,69,86,65,78,143,67,46,87,82,73,71,72,84,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
GAME_OVER_LINE_1:
	.DB BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,0
GAME_OVER_LINE_2:
	.DB BLACK,KEY_G,KEY_A,KEY_M,KEY_E,GREEN,KEY_O,KEY_V,KEY_E,KEY_R,BLACK,0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SOUND DATA
; 0-1 	REPEAT COUNT.  0 = 65535
; 2		DELAY COUNT
; 3-4	START_ADDR
; 5-6	END_ADDR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
SND_DATA	
	.DW 0x10				;REPEAT COUNT
	.DB 0x0F				;DELAY
	;.DW SND_SINE_START	
	;.DW SND_SINE_END
	.DW SND_TABL	
	.DW SND_TABL+4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DATA FOR SINE WAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SND_TABL
	.DB 0xFE,0x02,0x7F,0x02		; DATA BASIC FEEDS TO FF20 (SOUND)
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DELAY VALUES SHOWN ON LEFT WILL RESULT IN THE FOLLOWING NOTE
; NOTE THESE ARE FOR THE COCO2 RUNNING AT 0.89MHZ COCO3 VALUES
; WILL BE DIFFERENT BECAUSE OF THE FASTER CLOCK SPEED
; 60 = A#
; 64 = A (880 HZ)
; 69 = G# (830 HZ)
; 73 = G (783 HZ)
; 78 = F# (749 HZ)
; 83 = F (698 HZ)
; 88 = E (659 HZ)
; 94 = D# (622 HZ)
; 100 = D (587 HZ)
; 106 = C# (55 4HZ)
; 110 = Middle C (523 HZ)
; 120 = B
; 127 = A#
; 135 = A (440HZ)
;
; TO GET THE OUTER LOOP TIME (THE TONE LENGHT), JUST USE
; THE FREQUENCY FROM THE TABLE ABOVE (WILL REQUIRE 16 BITS)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FREQ .DB 255	
TONE_LENGTH .DW 0x00FF
	END START 