;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FLOOD-IT FOR TRS-80 COCO MODEL 2
;EVAN C. WRIGHT, 2016
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KBSCAN 	EQU $A1CB
LAST_LINE EQU 1504 
VRAM_END EQU (1024+512)
KEY_ESC EQU 3
KEY_B EQU 66
KEY_D EQU 68
KEY_E EQU 69
KEY_G EQU 71
KEY_H EQU 72
KEY_I EQU 73
KEY_L EQU 76
KEY_P EQU 80
KEY_Q EQU 81
KEY_R EQU 82
KEY_T EQU 84
KEY_U EQU 85
KEY_W EQU 87
KEY_X EQU 88
KEY_Y EQU 89
KEY_2 EQU 50
KEY_5 EQU 53
KEY_EQUALS EQU 61
KEY_SLASH EQU 47
GREEN EQU 96
DARK_GREEN EQU 32
BLACK EQU 128
WHITE EQU 207
YELLOW EQU 159
BLUE EQU 175
LIGHT_BLUE EQU 223
RED EQU 191
VRAM EQU 1024
MAX_TURNS EQU 50
;PROG_LENGTH set END_DATA-START_DATA
	
	; .BIN FILE HEADER
;	.db 0x00	;
;	.dw PROG_LENGTH
;	.db 0x0E	; address to load prog into
;	.db 0x00

	ORG 0x0E00 ; START CODE HERE
START
;START_DATA: 
	LDU #0x7FFF ; setup user stack
	CLR TURNS	; SET TURNS TO 0	
	; set user stack to top of user ram
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOOP TO FILL THE SCREEN WITH ALL 'A' CHARS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDD #0		; loop counter
	LDY #1024	; load addr to copy to
fill_loop_top:
	PSHS D		; save A (loop counter)
	JSR RND5	;GET RND COLOR
	LDX NEXTFIB-1
	LDA COLORS,X
	STA ,Y+	; copy char to location stored in Y increment Y
	PULS D	; restore A (loop counter)
	ADDD	#1 ; increment loop counter
	CMPD #480	; done (hit bottom of screen)?
	BNE fill_loop_top
	JSR DRAW_LEGEND
	JSR DRAW_INSTRUCTIONS ; DRAWS OFFSCREEN
KB_LOOP:
	JSR KBSCAN  ; PUTS KEYCODE INTO A - 0 = NO KEY
	CMPA 0	
	BEQ KB_LOOP	; IF 0 (NO KEY), REPEAT LOOP
	;KEY WAS PRESSED
	CMPA #KEY_ESC
	BEQ DONE
	CMPA #KEY_H
	BNE @a
	JSR SWITCH_BUFFERS
	BRA KB_LOOP
@a	CMPA #KEY_B
	BNE @b
	LDA #BLUE
	STA NEW_COLOR	; B KEY 
	JSR START_FILL
	BRA KB_LOOP
@b	CMPA #KEY_Y		; Y KEY - YELLOW
	BNE @c
	LDA #YELLOW
	STA NEW_COLOR	
	JSR START_FILL
	BRA KB_LOOP
@c	CMPA #KEY_W		; W KEY - WHITE
	BNE @d
	LDA #WHITE
	STA NEW_COLOR
	JSR START_FILL
	BRA KB_LOOP
@d	CMPA #KEY_R		; R RED
	BNE @e
	LDA #RED
	STA NEW_COLOR	; R KEY 
	JSR START_FILL
	JMP KB_LOOP
@e	CMPA #KEY_G	; X KEY 
	BNE @f
	LDA #GREEN
	STA NEW_COLOR	
	JSR START_FILL
	JMP KB_LOOP	
@f	CMPA #KEY_X	; X KEY 
	BNE @g
	LDA #BLACK
	STA NEW_COLOR	
	JSR START_FILL
	JMP KB_LOOP	
@g	JMP KB_LOOP
DONE:	
	LDA #GREEN
	STA CLR_COLOR
	LDX #VRAM
	JSR CLS
	RTS ; return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE NEXT FIBONACCI NUMBER IN A AND NEXTFIB
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RND5:
	PSHS A
	;COMPUTE NEXT
	LDA FIB1
	ADDA FIB2
	STA NEXTFIB
	;SHIFT 2 INTO 1
	LDA FIB2
	STA FIB1
	;SHIFT NEW INTO 2
	LDA NEXTFIB
	STA FIB2
	;MASK OF LEFT BITS
;	ANDA RNDMASK
	CMPA #0
	BGE MODLOOP
	NEGA	; flip to pos
MODLOOP:
	CMPA #6
	BMI RNDDONE
	SUBA #6 ; SUBTRACT 5 OFF TO PUT NUMBER IN RANGE
	BRA MODLOOP
RNDDONE:
	STA NEXTFIB	
	PULS A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAW_LEGEND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DRAW_LEGEND:
	LDX #LEGEND
	LDY #LAST_LINE
	JSR STRCPY
	RTS

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAW_INSTRUCTIONS TO THE OFFSCREEN BUFFER
;THIS IS CALLED ON START TO DRAW THE OFFSCREEN 
;HELP PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DRAW_INSTRUCTIONS:
	LDA #BLACK
	STA CLR_COLOR
	LDX #SCREEN_BUFFER
	JSR CLS
	LDX #INSTRUCTIONS1
	LDY #SCREEN_BUFFER
	JSR STRCPY
	LDX #INSTRUCTIONS2
	LDY #SCREEN_BUFFER+32
	JSR STRCPY
	LDX #INSTRUCTIONS3
	LDY #SCREEN_BUFFER+64
	JSR STRCPY
	LDX #INSTRUCTIONS4
	LDY #SCREEN_BUFFER+96
	JSR STRCPY
	LDX #INSTRUCTIONS5
	LDY #SCREEN_BUFFER+128
	JSR STRCPY
	LDX #INSTRUCTIONS6
	LDY #SCREEN_BUFFER+160
	JSR STRCPY
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CLS
;CLEARS SCREEN WITH COLOR STORED IN CLR_COLOR
;X CONTANS ADDR TO CLEAR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLS:
	PSHS D,X,Y  ; SAVE REGISTERS
	LDY #0
@a	LDA CLR_COLOR 	
 	STA ,X+
	LDA	,Y+
	CMPY #512  ; bottom of screen mem
	BNE @a
	PULS Y,X,D  ; RESTORE REGISTERS
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;START_FILL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START_FILL:
	INC TURNS
	JSR CLEAR_FLAGS
	;SAVE THE ORIGNAL COLOR
	LDA VRAM
	STA OLD_COLOR
	;MAKE 0,0 THE NEW COLOR
	LDA #0
	PSHU A
	PSHU A
	JSR BUCKET_FILL
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BUCKET_FILL
;IF SQUARE IS INBOUNDS AND NOT MARKED AND
;COLOR OF SQUARE IS EQUAL TO OLD COLOR,
;MAKE IT THE NEW COLOR AND BUCKET FILL THE
;SUROUNDING SQUARES
;THE X,Y COORD OF THE SQUARE TO FILL IS 
;PASSED ON THE USER STACK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BUCKET_FILL:
	;GET THE SQUARE TO CLEAR
	PULU A 
	STA Y_COORD
	PULU A
	STA X_COORD
	;SEE IF X,Y ARE ON THE BOARD	
	CMPA #0xFF	; -1
	BEQ @x
	CMPA #32	; OFF RIGHT EDGE	
	BEQ @x
	LDA Y_COORD
	CMPA #0xFF	; -1
	BEQ @x		;OFF TOP
	CMPA #15	; BOTTOM ROW
	BEQ @x		;OFF BOTTOM
	;SEE IF IT'S BEEN MARKED ALREADY
	LDA #32
	LDB Y_COORD
	MUL
	ADDB X_COORD
	BCC @nc	; NO CARRY
	INCA	; ADD CARRY TO A
	;D NOW CONTAINS THE OFFSET OF THE FLAG
@nc	TFR D,X
	LDA FLAGS,X
	CMPA #1	; ALREADY MARKED?
	BEQ @x	; BAIL IF ALREADY MARKED
	;IS THE COLOR OF THIS SQUARE EQUAL TO THE OLD_COLOR?
	LDA VRAM,X
	CMPA OLD_COLOR
	BNE @x
	;MAKE IT THE NEW COLOR
	LDA NEW_COLOR
	STA VRAM,X
	;MARK THE SQUARE
	LDA #1
	STA FLAGS,X
	;BUCKET FILL THE FOUR SURROUNDING SQUARES
	; FILL RIGHT (X+1,Y)
	LDA X_COORD
	INCA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL	
	; FILL LEFT (X-1,Y)
	LDA X_COORD
	DECA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL 
	; FILL UP  (X,Y-1)
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	INCA 
	PSHU A
	JSR BUCKET_FILL
	; FILL DOWN
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	DECA 
	PSHU A
	JSR BUCKET_FILL
@x	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CLEAR_FLAGS
; SETS EACH OF THE 60 FLAG BYTES TO 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLEAR_FLAGS:
	LDY #0		;loop counter
	LDX #FLAGS	;start addr
@a	LDA 0
	STA ,X+ 	;clear the byte
	LDA ,Y+		;inc loop counter (clobbers a)
	CMPY #480
	BNE @a
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CHECK WIN
;SCAN THE SCREEN MEMORY LOOKING FOR A CHAR THAT
;DOESN'T MATCH THE FIRST.  THE RESULT (0 or 1)
;IS RETURNED ON THE USER STACK.
;REGISTERS ARE NOT AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_WIN:
	PSHS D,X,Y
	LDY #0		; LOOP COUNTER
	LDX #VRAM+1	;	ADDRESS OF VIDEO RAM
	LDA VRAM	;	LOAD 1ST CHAR OF VRAM
	STA TEMP	;	SAVE 1ST CHAR IN TEMP	
@lp	LDA ,X+		;	GET CHAR FROM SCREEN_MEM
	CMPA TEMP	;	DOES IT MATCH THE 1ST CHAR
	BNE @no 	;	FOUND A CHAR THAT DIDN'T MATCH THE FIRST
	LDA ,Y+		;	INC LP COUNTER
	CMPY #480	;	HIT END?
	BNE @lp		;	LOOP
	LDA #1		;	IF GOT HERE, LOOP DONE, ALL CHARS ON SCRN ARE THE SAME		
	BRA @r	;	DONE
@no	LDA #0	; 0 = NOT FOUND
@r	PSHU A
	PULS Y,X,D
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SWITCH_BUFFERS
; THIS ROUTINE COPIES THE SCREEN MEMORY INTO
; GRAPHICS BUFFER 1. THIS IS REQUIRED PRIOR
; TO DISPLAYING THE HELP SCREEN SO THE BOARD
; STATE DOESN'T GET CLOBBERED.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SWITCH_BUFFERS:
	PSHS A,X,Y
	LDX #VRAM
	LDY #SCREEN_BUFFER
@a	LDA ,X		;SAVE SCREEN BYTE
	STA TEMP
	LDA ,Y		;LOAD BUFFER BYTE
	STA ,X		;COPY BUFFER BYTE TO SCREEN
	LDA TEMP	;GET SCREEN BYTE BACK
	STA ,Y		;COPY SCREEN TO BUF
	LDA ,X+ ; INC X
	LDA ,Y+ ; INC Y
	CMPX #VRAM_END ; DONE?
	BNE @a
	PULS Y,X,A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; STRCPY:
; SRC AND DEST NEED TO BE STORED IN X,Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
STRCPY:
	PSHS A
@a	LDA ,X+
	CMPA 0
	BEQ STRCPY_DONE
	STA ,Y+
	BRA @a
STRCPY_DONE:
	PULS A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
; program data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	COLOR CODE ARRAY
COLORS:
	.db GREEN	; DARK GREEN
	.db BLACK
	.db WHITE
	.db BLUE 
	.db YELLOW 
	.db RED
;	RANDOM NUMBER STUFF
FIB1:		
	.db 1 ; 55
FIB2:
	.db 1 ; 89
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
NEXTFIB:	
	.db 1 
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
OLD_COLOR .db 0	;	ORIGINAL COLOR OF 0,0 BEFORE BUCKET FILL
NEW_COLOR .db 0	;	COLOR TO BUCKET FILL WITH
CLR_COLOR .db 32	
TURNS .db 0	;
TEMP	.db 0
TEMP_WORD .dw 0
X_COORD .db 0
Y_COORD .db 0
LEGEND:	
	.STRZ "MOVES   /25   H=HELP  BREAK=QUIT"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	MARKED_FLAGS: WHERE EACH SQUARE HAS BEEN MARKED
;   BY THE FLOOD FILL ALGORITHM.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAGS .RS 480	;
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HELP SCREEN BUFFER.  THIS SECTION CONTAINS
;16 LINES OF 32 CHARACTERS.  WHEN THE HELP SCREEN IS
;DISPLAYED THE CONTENTS OF THIS MEMORY AND THE VRAM
;WILL BE SWITCHED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
SCREEN_BUFFER:
	.RS 512
INSTRUCTIONS1:
	.STRZ "THE OBJECTIVE IS TO MAKE THE "	
INSTRUCTIONS2:
	.STRZ "SCREEN ALL ONE COLOR.  YOU CAN"
INSTRUCTIONS3:
	.STRZ "DO THIS BY STRATEGICALLY"
INSTRUCTIONS4:
	.STRZ "BUCKET FILLING THE TOP LEFT"
INSTRUCTIONS5:
	.STRZ "SQUARE. HOWEVER, YOU ONLY HAVE"
INSTRUCTIONS6:
	.STRZ "25 TURNS, SO CHOOSE YOUR MOVES"
INSTRUCTIONS7:
	.STRZ "WISELY. USE THE FOLLOWING KEYS"
INSTRUCTIONS8:	
	.STRZ "X KEY = BLACK. B=BLUE"
INSTRUCTIONS9:
	.STRZ "W KEY = WHITE. C=CYAN"
INSTRUCTIONS10:
	.STRZ "G KEY = GREEN. Y=YELLOW"
INSTRUCTIONS_11:
	.STRZ "PRESS SPACE TO RETURN TO GAME."
	
	END START