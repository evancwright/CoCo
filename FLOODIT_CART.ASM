;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FLOOD-IT FOR TRS-80 COCO MODEL 2
;EVAN C. WRIGHT, 2016
;IMPORTANT!!!! THIS FILE IS FOR THE CATRIDGE VERSION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;KBSCAN 	EQU $A1CB
POLLKB	EQU $A000 ; VECTOR TO KBSCAN
LAST_LINE EQU (1024+480) 
TURNS_COORD EQU (1024+487)
VRAM_END EQU (1024+512)
LINE_ONE_END EQU (1024+32)
TOP_SQUARE EQU (1024+40)
SND_REPEAT_COUNT EQU $3F00
;	SND_DELAY EQU $3F02
SND_START_ADDR EQU $3F03
SND_END_ADDR EQU $3F05
VARIABLE_RAM_ADDR EQU 0x0E00  ; VARIABLE SPACE FOR CARTRIDGE RAM

	INCLUDE KEYS.ASM
	INCLUDE SNDDEFS.ASM
	INCLUDE GRFX.ASM
	
GREEN EQU 96
DARK_GREEN EQU 32
BLACK EQU 128
WHITE EQU 207
YELLOW EQU 159
BLUE EQU 175
CYAN EQU 223
RED EQU 191
ORANGE EQU 255
MAGENTA EQU 247
VRAM EQU 1024
MAX_TURNS EQU 30

	;ORG 0x0E00 ; START CODE HERE
	;ORG 0x0E00 ; START CODE HERE  (WHEN IT'S A BIN DISK FILE )
	 ORG 0XC000 ; START OF CARTRIDGE ROM
	
START
	.DW 0x444B
	LDU #0x3FFF ; setup user stack ; 
;	LDU #0x3FFF  ; PLACE FOR USER STACK IN .BIN VERSION
;	LDS #0x200	 ; SYSTEM STACK IS CRASHING INTO OS DATA BELOW IT
	LDS #0x7FFF
	CLR TURNS	; SET TURNS TO 0	
	JSR SEED_RND 
	JSR RELOCATE_VARS
	LDA #0			;CLEAR PREVIOUS QUIT_FLAG
	STA QUIT_FLAG
	;COPY THE INTRO TO SCREEN MEMORY
	LDY #INTRO_BUFFER
	JSR BUFFER_TO_SCREEN
	JSR FILL_INTRO
	JSR PLAY_WIN_MUSIC
	;WAIT FOR SPACEBAR
	JSR WAIT_ANY_KEY
	;COPY THE RANDOM SEED INTO THE RANDOM NUMBER
	LDD RAND_SEED
	STD CUR_RAND 
	;START GAME
	JSR CREATE_BOARD
KB_LOOP:
;	LDA QUIT_FLAG ; SEE IF THE PREVIOUS MOVE SET THE QUIT FLAG
;	CMPA #1
;	BEQ DONE	; IF NOT QUITTING, FALL THROUGH AND CHECK KB
	JSR [POLLKB]  ; PUTS KEYCODE INTO A - 0 = NO KEY 	
	BEQ KB_LOOP
;	CMPA #0	
;	BEQ KB_LOOP	; IF 0 (NO KEY), REPEAT LOOP
	;KEY WAS PRESSED
;	CMPA #KEY_ESC
;	BEQ DONE
	CMPA #KEY_H
	BNE @a
	JSR SHOW_HELP
	BRA KB_LOOP
@a	CMPA #KEY_B
	BNE @b
	LDA #BLUE
	STA NEW_COLOR	; B KEY 
	JSR START_FILL
	BRA KB_LOOP
@b	CMPA #KEY_Y		; Y KEY - YELLOW
	BNE @c
	LDA #YELLOW
	STA NEW_COLOR	
	JSR START_FILL
	BRA KB_LOOP
@c	CMPA #KEY_W		; W KEY - WHITE
	BNE @d
	LDA #WHITE
	STA NEW_COLOR
	JSR START_FILL
	BRA KB_LOOP
@d	CMPA #KEY_R		; R RED
	BNE @e
	LDA #RED
	STA NEW_COLOR	; R KEY 
	JSR START_FILL
	JMP KB_LOOP
@e	CMPA #KEY_G		; G KEY 
	BNE @f
	LDA #GREEN
	STA NEW_COLOR	
	JSR START_FILL
	JMP KB_LOOP	
@f	CMPA #KEY_C		  
	BNE @g
	LDA #CYAN
	STA NEW_COLOR	
	JSR START_FILL
@g	JMP KB_LOOP
DONE:				;CART VERSION WILL NEVER GET HERE
	LDA #GREEN
	STA CLR_COLOR
	LDX #VRAM
	JSR CLS
	RTS ; return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOOP TO FILL THE SCREEN WITH RANDOM COLOR CODES
; REGISTERS ARE CLOBBERED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CREATE_BOARD:
	LDA #0
	STA TURNS
	LDA #BLACK
	STA CLR_COLOR
	LDX #VRAM
	JSR CLS
	LDD #0			; loop counter
	LDY #(1024+39)	; load addr to copy to
@ot PSHS A			; save A (loop counter)
	;DO INNER
	LDB #0
@in	PSHS B
	;JSR RND5	;GET RND COLOR
	;LDX NEXTFIB-1
	JSR RAND_5   ; USE LSR TO GET NEW RANDOM
	LDX RAND	 ; GET LSB OF RANDOM NUMBER	
	LDA COLORS,X
	STA ,Y+	; copy char to location stored in Y increment Y
	PULS B
	INCB
	CMPB #16
	BNE @in
	LEAY 16,Y ;BUMP Y TO NEXT ROW
	;END INNER
	PULS A
	INCA
	CMPA #14
	BNE @ot	
	JSR DRAW_LEGEND  ; CLEAR BOTTOM LINE
	LDA TURNS		; OVERLAY TURNS	ON LEGEND
	LDX #TURNS_COORD
	JSR	ATOI		
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS INITIAL VALUES INTO FIB 1 AND FIB 2016
;FIB1 IS LOADED WITH HEX 113 WHICH IS A BASIC TIMER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SEED_RND:
	PSHS A
	LDA $113
	STA FIB1
	PULS A
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE NEXT FIBONACCI NUMBER IN A AND NEXTFIB
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RND5:
	PSHS A
	;COMPUTE NEXT
	LDA FIB1
	ADDA FIB2
	STA NEXTFIB
	;SHIFT 2 INTO 1
	LDA FIB2
	STA FIB1
	;SHIFT NEW INTO 2
	LDA NEXTFIB
	STA FIB2
	;MASK OF LEFT BITS
;	ANDA RNDMASK
	CMPA #0
	BGE MODLOOP
	NEGA	; flip to pos
MODLOOP:
	CMPA #6
	BMI RNDDONE
	SUBA #6 ; SUBTRACT 5 OFF TO PUT NUMBER IN RANGE
	BRA MODLOOP
RNDDONE:
	STA NEXTFIB	
	PULS A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;LSR RANDOM NUMBER ROUTINE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RAND_5:
NEXT_RAND
	PSHS D
	LDB CUR_RAND+1 ; GET RIGHT BYTE
	ANDB LEFT_TAP_MASK ; MASK RAND TO GET LEFT TAP	
	STB LEFT_TAP			;SAVE IT
	LDB CUR_RAND+1		;RELOAD
	ANDB RIGHT_TAP_MASK	; MASK RAND TO GET RIGHT TAP
	;RIGHT TAP IS THE LSB (SO WE DON'T NEED TO SHIFT)
	STB RIGHT_TAP
	LSL RIGHT_TAP	;LEFT JUSTIFY THE RIGHT TAP 
	LSL RIGHT_TAP	;SO THE TWO TAPS CAN BE 
	LSL RIGHT_TAP	;XOR'D AND EASILY
	LSL RIGHT_TAP	;MASKED BACK ONTO THE LEFT
	LSL RIGHT_TAP	;BYTE OF THE RANDOM NUMBER
	LSL RIGHT_TAP
	LSL RIGHT_TAP
	;NOW WE HAVE BOTH TAPS, XOR THEM
	LDA LEFT_TAP
	EORA RIGHT_TAP	
	STA XOR_RSLT
	;NOW SHIFT
	LDD CUR_RAND	;LOAD LEFT BYTE
	LSRA ; PUTS BIT 0 INTO CARRY BIT 
	STA CUR_RAND ; STORE NEW MSB
	BCC @nc
	LDB	CUR_RAND+1	;THERE WAS A CARRY
	LSRB
	ORB ONE_IN_MSB ;  MASK A 1 ONTO THE LEFT MOST BIT
	BRA @ds	 ;  DONE SHIFTING
@nc	
	LDB	CUR_RAND+1 ; JUST SHIFT, NO 1 ON LEFT
	LSRB
@ds STB CUR_RAND+1 	; STORE RIGHT HALF OF NEW RAND
	;NOW MASK THE XOR_RSLT ONTO THE MSB
	LDA CUR_RAND
	ORA XOR_RSLT	; MASK A '1' ONTO THE MSB
	STA CUR_RAND
	;SUBTRACT 1 SINCE THE WORKING RAND CAN'T CONTAIN 0
	LDD CUR_RAND	; RELOAD 2 BYTE VALUE
	SUBD #1		; DEC
	STD RAND
	LDA RAND+1  ; GRAB LSB
	ANDA RAND_MASK			; MASK OFF LEFT BITS TO KEEP IT FROM BEING < 0
MOD_LOOP:
	CMPA #6
	BMI RND_DONE
	SUBA #6 ; SUBTRACT 5 OFF TO PUT NUMBER IN RANGE
	BRA MOD_LOOP
RND_DONE:
	STA RAND+1	;THIS GETS LOADED INTO X, SO 
	LDA #0		;IT NEEDS TO BE PADDED TO 16 BITS
	STA RAND
	PULS D
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAW_LEGEND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DRAW_LEGEND:
	LDX #TOP_LINE
	LDY #VRAM
	JSR STRCPY
	LDX #LEGEND
	LDY #LAST_LINE
	JSR STRCPY
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REGISTERS GET CLOBBERED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FILL_INTRO:
	LDY  #(VRAM+96)
@lp LDA ,Y			; LOAD SCREEN BYTE
	CMPA #0x8F		; GREEN?
	BEQ @pl			; NO-SKIP
	LDA #2			; PLAY BEEP
	STA SOUND_LENGTH
	LDA FREQ
	;STA $400
	INCA 
	STA FREQ
	PSHS Y
	NOP ;	JSR SOUND_PLAY2
	LDA #BLUE		; YES, MAKE IT BLUE
	PULS Y
	STA ,Y
@pl LEAY 1,Y		;INC Y	
	JSR WASTE_TIME	;IF NOT USING SOUND, THEN NEED TO WASTE TIME
	JSR WASTE_TIME
	JSR WASTE_TIME
	CMPY #1280	;DONE (just below title on screen)
	BNE @lp
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PLAY BEEP
; USED BY FILL INTRO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
PLAY_BEEP
	PSHS D
	LDB FILL_FREQ	; PLAY A BEEP
	ADDB #1		; INCREASE TONE BY 10 EACH STEP Produces Beep of length B, pitch in $008c
	STB FILL_FREQ	; SAVE IT FOR NEXT LOOP	
	STB BEEP_FREQ	; STORE FREQ IN 8C  (8C is multiplied into 8D)
	LDB #1		; BEEP LENGTH OF 1
	ANDCC #$EF		; TURN OFF BIT IN CC TO ENABLE INTERRUPT (TO COUNT DOWN SND TIMER)
	JSR ENABLE_SOUND
	JSR BEEP_SUB	
;@lp	LDD $8D				; LOOP TO SEE IF THE SOUND IS DONE
;	CMPD #0
;	BNE @lp
;	PULS D
;	JSR DISABLE_SOUND
;	ORCC #$10	; RESET INTERRUPT FLAG
	RTS	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CLS
;CLEARS SCREEN WITH COLOR STORED IN CLR_COLOR
;X CONTANS ADDR TO CLEAR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLS:
	PSHS D,X,Y  ; SAVE REGISTERS
	LDY #0
@a	LDA CLR_COLOR 	
 	STA ,X+
	LDA	,Y+
	CMPY #512  ; bottom of screen mem
	BNE @a
	PULS Y,X,D  ; RESTORE REGISTERS
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;START_FILL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START_FILL:
	;SAVE THE ORIGNAL COLOR
	LDA VRAM+39
	;LDA VRAM+40
	STA OLD_COLOR
	;MAKE SURE THE OLD COLOR AND NEW COLOR ARE NOT THE SAME
	CMPA NEW_COLOR
	BNE @k
;	JSR ERROR_BEEP			;OLD COLOR AND NEW COLOR ARE THE SAME
	JMP @x					;JUMP fTO RETURN AT END
@k	;INCREMENT THE TURNS SINCE WE KNOW THE MOVE IS VALID
	INC TURNS
	LDA TURNS
	LDX #TURNS_COORD
	JSR ATOI
	JSR CLEAR_FLAGS
	;MAKE 0,0 THE NEW COLOR (ACTUALLY 7,1 ON SMALLER BOARD)
	LDA #7
	PSHU A	; X
	LDA #1
	PSHU A	; Y
	JSR BUCKET_FILL
	JSR CHECK_WIN
	PULU A 	; GET RETURN CODE
	CMPA #1	; 1 IS A WIN
	BNE @no
	JSR HANDLE_WIN
	BRA @x
@no	LDA TURNS			; CHECK THE TURN
	CMPA #MAX_TURNS		;
	BNE @x				; STILL PLAYING
	JSR HANDLE_LOSE
@x	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BUCKET_FILL
;IF SQUARE IS INBOUNDS AND NOT MARKED AND
;COLOR OF SQUARE IS EQUAL TO OLD COLOR,
;MAKE IT THE NEW COLOR AND BUCKET FILL THE
;SUROUNDING SQUARES
;THE X,Y COORD OF THE SQUARE TO FILL IS 
;PASSED ON THE USER STACK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BUCKET_FILL:
	;STACK SANITY CHECK
	CMPU #6010 
	BGT @g
	NOP		; IF HERE, STACK ABOUT TO OVERFLOW
	;GET THE SQUARE TO CLEAR
@g	PULU B 
	STA Y_COORD
	PULU A
	STA X_COORD
	;SEE IF X IS ON THE BOARD	
	CMPA #6		; 	LEFT EDGE
	LBEQ @x
	CMPA #24	; OFF RIGHT EDGE	
	LBEQ @x
	;VERIFY Y (WHICH IS IN B)
	CMPB #0		; TOP ROW
	BEQ @x		;OFF TOP
	CMPB #15	; BOTTOM ROW
	BEQ @x		;OFF BOTTOM
	;SEE IF IT'S BEEN MARKED ALREADY
	;(COMPUTE OFFSET = Y*32+X)
	LDA #32
	MUL		; D = Y(WHICH IS IN B) * 32 (WHICH IS IN A)
	ADDB X_COORD	
	BCC @nc	; NO CARRY
	INCA	; ADD CARRY TO A
	;D NOW CONTAINS THE OFFSET OF THE FLAG
@nc	TFR D,X
	LDA FLAGS,X
	CMPA #1	; ALREADY MARKED?
	BEQ @x	; BAIL IF ALREADY MARKED
	;IS THE COLOR OF THIS SQUARE EQUAL TO THE OLD_COLOR?
	LDA VRAM,X
	CMPA OLD_COLOR
	BNE @x
	;MAKE IT THE NEW COLOR
	LDA NEW_COLOR
	STA VRAM,X
	;MARK THE SQUARE
	LDA #1
	STA FLAGS,X  ;AFTER THIS, DONE WITH OFFSET
	;BUCKET FILL THE FOUR SURROUNDING SQUARES
	; FILL RIGHT (X+1,Y)
	JSR SAVEXY
	LDA X_COORD
	INCA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL	
	JSR RESTOREXY
	; FILL LEFT (X-1,Y)
	JSR SAVEXY
	LDA X_COORD
	DECA
	PSHU A
	LDA	Y_COORD
	PSHU A
	JSR BUCKET_FILL 
	JSR RESTOREXY
	; FILL UP  (X,Y-1)
	JSR SAVEXY
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	DECA 
	PSHU A
	JSR BUCKET_FILL
	JSR RESTOREXY
	; FILL DOWN (X,Y+1)
	JSR SAVEXY
	LDA X_COORD
	PSHU A
	LDA Y_COORD	
	INCA 
	PSHU A
	JSR BUCKET_FILL	
	JSR RESTOREXY
@x	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CLEAR_FLAGS
; SETS EACH OF THE 60 FLAG BYTES TO 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLEAR_FLAGS:
	LDY #0		;loop counter
	LDX #FLAGS	;start addr
@a	LDA 0
	STA ,X+ 	;clear the byte
	LDA ,Y+		;inc loop counter (clobbers a)
	CMPY #480
	BNE @a
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CHECK WIN
;SCAN THE SCREEN MEMORY LOOKING FOR A CHAR THAT
;DOESN'T MATCH THE FIRST.  THE RESULT (0 or 1)
;IS RETURNED ON THE USER STACK.
;REGISTERS ARE NOT AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_WIN:
	PSHS D,X,Y
	LDY #0		; LOOP COUNTER 
	LDX #(VRAM+32)	;	ADDRESS OF 2ND LINE IN VIDEO RAM (START OF COMPARISON)
	LDA VRAM+39	;	LOAD 1ST CHAR OF VRAM
	STA TEMP	;	SAVE 1ST CHAR IN TEMP	
@lp	LDA ,X+		;	GET CHAR FROM SCREEN_MEM
	CMPA #BLACK	; 	SKIP BLACK (PART OF BACKGROUND)
	BEQ @sk		; 
	CMPA TEMP	;	DOES IT MATCH THE 1ST CHAR
	BNE @no 	;	FOUND A CHAR THAT DIDN'T MATCH THE FIRST
@sk	LEAY 1,Y		;	INC LP COUNTER
	CMPY #447	;	HIT END? (512-32x32-1)
	BNE @lp		;	LOOP
	LDA #1		;	IF GOT HERE, LOOP DONE, ALL CHARS ON SCRN ARE THE SAME		
	BRA @r	;	DONE
@no	LDA #0	; 0 = NOT FOUND
@r	PSHU A	; PUSH RESULT ON STACK, CALLER WILL POP IT OFF
	PULS Y,X,D
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SCREEN TO BUFFER
; THIS ROUTINE COPIES THE SCREEN MEMORY INTO
; THE GRAPHICS BUFFER IN REGISTER Y.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCREEN_TO_BUFFER:
	PSHS A,X
	LDX #VRAM
@a	LDA ,X		;SAVE SCREEN BYTE
	STA ,Y		;COPY SCREEN TO BUF
	LEAX 1,X ; INC X
	LEAY 1,Y ; INC Y
	CMPX #VRAM_END ; DONE?
	BNE @a
	PULS X,A	
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SCREEN TO BUFFER
; THIS ROUTINE COPIES FROM MEMORY TO THE SCREEN
; THE GRAPHICS BUFFER IN REGISTER Y.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BUFFER_TO_SCREEN:
	PSHS A,X
	LDX #VRAM
@a	LDA ,Y		;SAVE SCREEN BYTE
	STA ,X		;COPY SCREEN TO BUF
	LEAX 1,X ; INC X
	LEAY 1,Y ; INC Y
	CMPX #VRAM_END ; DONE?
	BNE @a
	PULS X,A	
	RTS	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SWITCH_BUFFERS
; THIS ROUTINE COPIES THE SCREEN MEMORY INTO
; THE GRAPHICS BUFFER IN REGISTER Y.
;
; THE SRC IS ASSUMED TO BE THE SCREEN MEMORY
; Y CONTAINS ADDRESS OF OFFSCREEN BUFFER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SWITCH_BUFFERS:
	PSHS A,X
	LDX #VRAM
@a	LDA ,X		;SAVE SCREEN BYTE
	STA TEMP
	LDA ,Y		;LOAD BUFFER BYTE
	STA ,X		;COPY BUFFER BYTE TO SCREEN
	LDA TEMP	;GET SCREEN BYTE BACK
	STA ,Y		;COPY SCREEN TO BUF
	LDA ,X+ ; INC X
	LDA ,Y+ ; INC Y
	CMPX #VRAM_END ; DONE?
	BNE @a
	PULS X,A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SAVEXY
;PUTS X_COORD AND Y_COORD ON THE USER STACK
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SAVEXY:
	PSHS A
	LDA X_COORD
	PSHU A
	LDA Y_COORD
	PSHU A
	PULS A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTOREXY
;PULS X_COORD AND Y_COORD OFF THE USER STACK
;AND BACK INTO THEIR MEMORY LOCATIONS
;NO REGISTERS AFFECTED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESTOREXY:
	PSHS A
	PULU A
	STA Y_COORD
	PULU A
	STA X_COORD
	PULS A
	RTS	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HANDLE_LOSE
;CALLED WHEN THE PLAYER LOSES
;WAITS FOR ANY KEY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HANDLE_LOSE:
	JSR SHOW_LOSE_MESSAGE
	JSR WAIT_ANY_KEY
;	LDA QUIT_FLAG	; CART VERSION DOESN'T LET YOU QUIT
;	CMPA #1
;	BEQ @x
	JSR CREATE_BOARD	
@x	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HANDLE_WIN
;CALLED WHEN THE PLAYER WINS OR LOSES
;WAITS FOR ANY KEY AND SETS THE QUIT FLAG
;IF NEEDED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HANDLE_WIN:
	JSR PLAY_WIN_MUSIC
	JSR SHOW_WIN_MESSAGE
	JSR WAIT_ANY_KEY
	;LDA QUIT_FLAG	; THESE DON'T APPLY TO THE CART VER.
	;CMPA #1
	;BEQ @x
	JSR CREATE_BOARD	
@x	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SHOW_HELP
; NO REGISTERS PRESERVED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SHOW_HELP:
	LDY #GAME_BUFFER		; SAVE GAME SCREEN
	JSR SCREEN_TO_BUFFER
	LDY #HELP_SCREEN_BUFFER	; HELP SCREEN TO SCREEN
	JSR BUFFER_TO_SCREEN
	JSR WAIT_ANY_KEY
	LDY #GAME_BUFFER	; MOVE GAME BACK TO SCREEN
	JSR BUFFER_TO_SCREEN
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE GAME OVER MESSAGE ON THE SCREEN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SHOW_LOSE_MESSAGE:
	LDX #GAME_OVER_LINE_1
	LDY #(1034+256)
	JSR STRCPY
	
	LDX #GAME_OVER_LINE_2
	LDY #(1034+256+32)
	JSR	STRCPY
	
	LDX #GAME_OVER_LINE_1
	LDY #(1034+256+64)
	JSR STRCPY
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PUTS THE GAME OVER MESSAGE ON THE SCREEN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SHOW_WIN_MESSAGE:
	LDX #GAME_OVER_LINE_1	; SAME FOR WIN OR LOSE
	LDY #(1034+256)
	JSR STRCPY
	
	LDX #WIN_MSG_LINE_2
	LDY #(1034+256+32)
	JSR	STRCPY
	
	LDX #GAME_OVER_LINE_1	; SAME FOR WIN OR LOSE
	LDY #(1034+256+64)
	JSR STRCPY
	RTS	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	WASTE TIME
;	AN EMPTY LOOP TO WASTE TIME.  USED FOR
;	THE BLINKING WHEN THE PLAYER WINS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WASTE_TIME:
	PSHS A
	LDA #0xFF
@lp	DECA	
	CMPA #0
	BNE @lp
	PULS A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; STRCPY:
; SRC AND DEST NEED TO BE STORED IN X,Y
; REGISTERS ARE PRESERVED.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
STRCPY:
	PSHS D,X,Y
@a	LDA ,X+
	CMPA 0
	BEQ @x
	STA ,Y+
	BRA @a
@x	PULS Y,X,D
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DRAWS AN 8 BsIT NUMBER TO THE SCREEN
;ONLY WORKS FOR POSITIVE NUMBERS
;A CONTAINS NUMBER
;X CONTAINS RIGHT EDGE OF SCREEN LOCATION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ATOI:
@lp	JSR A_DIV_10	;DIVIDE BY 10, REMAINDER IN B
	ADDB #48		;CONVERT B TO CHAR CODE (NUMBERS START AT 48)
	STB	,X			;DRAW TO SCREEN
	LEAX -1,X		;SHIFT LEFT ON SCREEN
	CMPA #0			;DONE?
	BNE @lp
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DIVIDES A BY TEN AND PUTS THE REMAINDER IN B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
A_DIV_10:
	LDB #0
@lp CMPA #10
	BLT @x		; 10 WON'T GO IN, DONE
	SUBA #10 	; SUBTRACT 10
	INCB		
	BRA @lp		
@x	
	EXG	B,A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;WAITS UNTIL A KEY IS PRESSED.
;IF THE KEY WAS ESC, THE QUIT_FLAG IS SET TO 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_ANY_KEY
@l	JSR [POLLKB]  ; PUTS KEYCODE INTO A - 0 = NO KEY
	INC RAND_SEED ; COUNT TICKS TO USE AS A SEED #
	CMPA #0
	BEQ @l
;CART VERSION CAN'T QUIT
;	CMPA #KEY_ESC
;	BNE @x
;	LDA #1
;	STA QUIT_FLAG
@x	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PLAYS THE WIN MUSIC 
;A IS CLOBBERED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
PLAY_WIN_MUSIC
	LDA #3
@lp	PSHS D,X,Y
	LDA	#5		;LENGTH (0.125 x 440HZ)
	STA SOUND_LENGTH
	LDA #60		;A
	STA FREQ
	JSR SOUND_PLAY2
	LDA	#8		;LENGTH (0.125 x 587)
	STA SOUND_LENGTH
	LDA #110	;D
	STA FREQ
	JSR SOUND_PLAY2
	LDA	#8		;LENGTH (0.125 x  749)
	STA SOUND_LENGTH
	LDA #142	;F#
	STA FREQ
	JSR SOUND_PLAY2	
	PULS Y,X,D
	DECA
	CMPA #0
	BNE @lp
	RTS	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MULTIPLIES Y TIMES 8. USED BY SOUND_PLAY2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YTIMES6
	PSHS D
	EXG Y,D  ; Y->D
	STD TEMP_WORD
	LDY #4
@lp ADDD TEMP_WORD 	
	LEAY -1,Y
	CMPY #0
	BNE @lp
	EXG D,Y ; D->Y
	PULS D
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ERROR BEEP
;PLAYS A SHORT ERROR TONE
;REGISTERS ARE PRESERVED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ERROR_BEEP:	
	PSHS A,Y
	LDY	#2		;LENGTH (short)
	LDA #255	;LOW A
	STA FREQ
	JSR SOUND_PLAY2
	PULS Y,A
	RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PERFORMS 8 BIT DIVISION
; OPERANDS STORED IN MEMORY BEFORE CALLED (DIVIDEND AND DIVISOR)
; RESULTS PUT IN MEMORY LOCATIONS (QOUTIENT, REMAINDER)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DIV8:
	PSHS D
	CLR QUOTIENT
	CLR REMAINDER
	LDA DIVIDEND
	LDB DIVISOR
@dv CMPA DIVISOR	; CAN WE DIVIDE?
	BMI	@x			; IF NO, DONE
	INC QUOTIENT	; IF YES, INC QOUTIENT
	SUBA DIVISOR	; AND REPEAT
	BRA @dv 
@x	STB REMAINDER	
	PULS D
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PLAYS A TONE 
; FREQ NEEDS TO BE IN FREQ BYTE
; Y CONTAINS THE NUMBER OF TIMES TO LOOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SOUND_PLAY
	;SETUP SND
	LDA PIA_CTRL1
	ANDA #$F7		;RESET MUX BIT (WHY?)
	STA PIA_CTRL1	; (SOUND TO SPKR?)
	LDA PIA_CTRL2	
	ANDA #$F7
	STA PIA_CTRL2 ; (SOUND ON?)
	LDA PIA_SND_ENABLE
	ORA #8			; GET BIT 6
	STA PIA_SND_ENABLE
	;MAIN SOUND LOOP - THE DELAY WHICH 
	;CONTROLS THE 
	;LDY SND_DATA	; LOAD REPEAT COUNT (NOW SUPPLIED BY CALLER)
@o	LDX	SND_DATA+3	; LOAD START ADDR
@i	LDA ,X+			; GET NEXT BYTE
	ANDA #$FC		; RESET 2 LS BITS
	STA	PIA_DATA
	JSR SND_DELAY	; USE DELAY TO CONTROL FREQ (USES FREQ)
	CMPX SND_DATA+5	; TEST FOR END ADDR
	BNE @i			; KEEP GOING
	LEAY -1,Y		; DEC MAIN LP COUNTR (SETS Z FLAG)
	BNE @o			; START OVER AT BEGINNING OF SOUND DATA
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PLAYS A TONE 
; FREQ LOCATION CONTAINS FREQUENCY
; SOUND_LENGTH CONTAINS THE NUMBER OF TIMES TO LOOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SOUND_PLAY2
	;ADJUST THE LENGTH BASED ON FREQ
	LDA SOUND_LENGTH
	STA DIVIDEND
	LDB FREQ
	STB DIVISOR
	JSR DIV8
	STA QUOTIENT 
	;MAIN SOUND LOOP - THE DELAY WHICH 
	LDY QUOTIENT_16
	JSR YTIMES6
	;SETUP SND
	;LDA #65
	;STA $400
	LDA PIA_CTRL1
	ANDA #$F7		;RESET MUX BIT (WHY?)
	STA PIA_CTRL1	; (SOUND TO SPKR?)
	;LDA #66
	;STA $400
	LDA PIA_CTRL2	
	ANDA #$F7
	STA PIA_CTRL2 	; (SOUND ON?)
	;LDA #67
	;STA $400
	LDA PIA_SND_ENABLE
	ORA #8			; GET BIT 6
	STA PIA_SND_ENABLE
	;LDA #68
	;STA $400
	;MAIN LOOP
	LEAY 1,Y		;MAKE SURE Y IS NOT 0
@o	LDX	SND_DATA+3	; LOAD START ADDR
@i	LDA ,X+			; GET NEXT BYTE
	ANDA #$FC		; RESET 2 LS BITS
	STA	PIA_DATA
	JSR SND_DELAY	; USE DELAY TO CONTROL FREQ
	CMPX SND_DATA+5	; TEST FOR END ADDR
	BNE @i			; KEEP GOING
	LEAY -1,Y		; DEC MAIN LP COUNTR (SETS Z FLAG)
	BNE @o			; START OVER AT BEGINNING OF SOUND DATA
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	WASTE TIME
;	AN EMPTY LOOP TO WASTE TIME. 
;	THIS ROUTINE WILL GET CALLED 4 TIMES
;	PER SINE WAVE CYCLE.
;
;	CYCLES: 14 + 11 TIME THROUGH THE LOOP
;	25 CYCLES = 35,600 HZ
;	
;	@440HZ EACH CYCLE NEEDS TO TAKE .0022 seconds
;	THAT MEANS 4 LOOPS OF .00056 SECS
;	TO MAKE EACH DELAY TAKE .00056 SECONDS
;	THE LOOP COUNT NEEDS TO BE 500 cycles long
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SND_DELAY:
	PSHS A		; 4
	LDA #255	;
	SUBA FREQ	; 5
@lp	DECA		; 2
	CMPA #0		; 2
	BNE @lp		; 3
	PULS A		; 4
	RTS			; 5
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;THIS CODE COPIES VARIABLES FROM THE PROGRAM
;ROM INTO THE RAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RELOCATE_VARS:
	PSHS A,X,Y
	LDX #0
@lp LDA PROGRAM_AREA_END,X
	STA VARIABLE_RAM_ADDR,X
	LEAX 1,X
	CMPX VAR_SPACE_SIZE
	BLT @lp
	PULS Y,X,A
	RTS
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
; program data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	COLOR CODE ARRAY
COLORS:
	.db GREEN	; DARK GREEN
	.db CYAN
	.db WHITE
	.db BLUE 
	.db YELLOW 
	.db RED
TOP_LINE:
	;.STRZ "Flood it! coco ver. by e. wright"
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE	;6
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE ;6
	.DB INVERSE_F,INVERSE_L,INVERSE_O,INVERSE_O,INVERSE_D,INVERSE_SPACE,INVERSE_SPACE ;7
	.DB INVERSE_I,INVERSE_T,INVERSE_EXCL 	; 3
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE ;6
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE	;6
	.DB 0 ; NULL TERMINATOR
LEGEND:	
	;.STRZ "MOVES   /25   H=HELP  BREAK=QUIT" 
	.DB INVERSE_M,INVERSE_O,INVERSE_V,INVERSE_E,INVERSE_S,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE
	.DB INVERSE_SLASH,INVERSE_3,INVERSE_0,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE
	.DB INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE,INVERSE_SPACE
	.DB INVERSE_H,INVERSE_EQUALS,INVERSE_H,INVERSE_E,INVERSE_L,INVERSE_P,0 ; NULL TERMINATOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HELP SCREEN BUFFER.  THIS SECTION CONTAINS
;16 LINES OF 32 CHARACTERS.  WHEN THE HELP SCREEN IS
;DISPLAYED THE CONTENTS OF THIS MEMORY AND THE VRAM
;WILL BE SWITCHED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
HELP_SCREEN_BUFFER:
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,143,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,72,79,87,143,84,79,143,80,76,65,89,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,84,72,69,143,79,66,74,69,67,84,73,86,69,143,73,83,143,84,79,143,77,65,75,69,143,84,72,69,143,143
	.DB 143,143,66,79,65,82,68,143,65,76,76,143,79,78,69,143,67,79,76,79,82,143,73,78,143,85,78,68,69,82,143,143
	.DB 143,143,115,112,143,84,85,82,78,83,110,143,89,79,85,143,67,65,78,143,68,79,143,84,72,73,83,143,66,89,143,143
	.DB 143,143,83,84,82,65,84,69,71,73,67,65,76,76,89,143,66,85,67,75,69,84,143,70,73,76,76,73,78,71,143,143
	.DB 143,143,84,72,69,143,84,79,80,143,76,69,70,84,143,83,81,85,65,82,69,110,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,75,69,89,83,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,66,125,66,76,85,69,143,143,143,143,67,125,67,89,65,78,143,143,143,143,71,125,71,82,69,69,78,143,143,143
	.DB 143,143,82,125,82,69,68,143,143,143,143,143,87,125,87,72,73,84,69,143,143,143,89,125,89,69,76,76,79,87,143,143
	.DB 143,143,143,143,80,82,69,83,83,143,65,78,89,143,75,69,89,143,84,79,143,71,79,143,66,65,67,75,143,143,143,143
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
INTRO_BUFFER: ;	INTRO SCREEN
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,128,191,175,143,175,143,143,175,128,159,143,128,207,159,143,175,207,143,143,143,207,128,191,143,175,128,159,143,175,143
	.DB 143,143,207,143,143,143,159,143,143,191,143,128,143,159,143,191,143,128,143,175,143,143,143,159,143,143,143,191,143,143,159,143
	.DB 143,143,159,191,143,143,191,143,143,207,143,175,143,191,143,128,143,207,143,191,143,143,143,191,143,143,143,159,143,143,191,143
	.DB 143,143,207,143,143,143,175,143,143,175,143,191,143,207,143,191,143,159,143,207,143,143,143,207,143,143,143,207,143,143,143,143
	.DB 143,143,128,143,143,143,207,159,143,191,207,175,143,128,175,159,143,191,175,143,143,143,207,159,128,143,143,191,143,143,128,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,67,79,67,79,143,86,69,82,83,73,79,78,143,66,89,143,69,86,65,78,143,67,110,87,82,73,71,72,84,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
;	.DB 143,143,143,143,143,143,143,143,KEY_P,KEY_R,KEY_E,KEY_S,KEY_S,143,KEY_H,143,KEY_F,KEY_O,KEY_R,143,KEY_H,KEY_E,KEY_L,KEY_P,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,KEY_P,KEY_R,KEY_E,KEY_S,KEY_S,143,KEY_A,KEY_N,KEY_Y,143,KEY_K,KEY_E,KEY_Y,143,KEY_T,KEY_O,143,KEY_P,KEY_L,KEY_A,KEY_Y,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
GAME_OVER_LINE_1:
	.DB BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,BLACK,0
GAME_OVER_LINE_2:
	.DB BLACK,KEY_G,KEY_A,KEY_M,KEY_E,GREEN,KEY_O,KEY_V,KEY_E,KEY_R,BLACK,0
WIN_MSG_LINE_2:
	.DB BLACK,KEY_V,KEY_I,KEY_C,KEY_T,KEY_O,KEY_R,KEY_Y,KEY_EXCL,KEY_EXCL,BLACK,0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SOUND DATA
; 0-1 	REPEAT COUNT.  0 = 65535
; 2		DELAY COUNT
; 3-4	START_ADDR
; 5-6	END_ADDR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
SND_DATA	
	.DW 0x10				;REPEAT COUNT
	.DB 0x0F				;DELAY
	;.DW SND_SINE_START	
	;.DW SND_SINE_END
	.DW SND_TABL	
	.DW SND_TABL+4		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DATA FOR SINE WAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SND_TABL
	.DB 0xFE,0x02,0x7F,0x02		; DATA BASIC FEEDS TO FF20 (SOUND)
	
VAR_SPACE_SIZE .DW VARIABLE_AREA_END-VARIABLE_AREA_START
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   VARIABLES.  ALL STATIC DATA SHOULD BE BEFORE THIS SECTION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PROGRAM_AREA_END
	ORG 0x0E00
VARIABLE_AREA_START
DIVIDEND 	.db 0x00
DIVISOR 	.db 0x00
QUOTIENT_16 .db 0x00 ; padding (for loading it into Y)
QUOTIENT  	.db 0x00
REMAINDER 	.db 0x00
QUIT_FLAG	.db  0x00
;	RANDOM NUMBER STUFF
;DATA FOR RANDOM NUMBER GENERATION
RAND_SEED	.DW 0x0F0F
CUR_RAND			.DW 0x0F0F
RAND				.DW 0x0000
RAND_MASK			.DB 0x0F
ONE_IN_MSB		.DB 0x80
LEFT_TAP_MASK 	.DB 0x80 ; 1000 0000
RIGHT_TAP_MASK 	.DB 0x01 ; 0000 0001
LEFT_TAP  		.DB 0x00
RIGHT_TAP  		.DB 0x00
XOR_RSLT			.BYTE 0x00
FIB1:		
	.db 1 ; 55
FIB2:
	.db 2 ; 89
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
NEXTFIB:	
	.db 1 
	.db 0	;padding so we can load nextfib into  X (which is 16 bits)
OLD_COLOR .db 0	;	ORIGINAL COLOR OF 0,0 BEFORE BUCKET FILL
NEW_COLOR .db 0	;	COLOR TO BUCKET FILL WITH
CLR_COLOR .db 32	
TURNS .db 0	;
TEMP	.db 0
TEMP_WORD .dw 0
X_COORD .db 0
Y_COORD .db 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	MARKED_FLAGS: WHERE EACH SQUARE HAS BEEN MARKED
;   BY THE FLOOD FILL ALGORITHM.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAGS .RS 480	;  0/1 FLAGS FOR MARKING SQUARES

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BUFFER FOR THE GAME SCREEN.  THIS SECTION CONTAINS
;16 LINES OF 32 CHARACTERS.  WHEN THE HELP SCREEN IS
;DISPLAYED THE CONTENTS OF THE SCREEN WILL BE PUT HERE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
GAME_BUFFER:
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,143,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,72,79,87,143,84,79,143,80,76,65,89,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	 .DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,84,72,69,143,79,66,74,69,67,84,73,86,69,143,73,83,143,84,79,143,77,65,75,69,143,84,72,69,143,143
	.DB 143,143,66,79,65,82,68,143,65,76,76,143,79,78,69,143,67,79,76,79,82,143,73,78,143,85,78,68,69,82,143,143
	.DB 143,143,114,117,143,84,85,82,78,83,110,143,89,79,85,143,67,65,78,143,68,79,143,84,72,73,83,143,66,89,143,143
	.DB 143,143,83,84,82,65,84,69,71,73,67,65,76,76,89,143,66,85,67,75,69,84,143,70,73,76,76,73,78,71,143,143
	.DB 143,143,84,72,69,143,84,79,80,143,76,69,70,84,143,83,81,85,65,82,69,110,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,75,69,89,83,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143
	.DB 143,143,66,125,66,76,85,69,143,143,143,143,67,125,67,89,65,78,143,143,143,143,71,125,71,82,69,69,78,143,143,143
	.DB 143,143,82,125,82,69,68,143,143,143,143,143,87,125,87,72,73,84,69,143,143,143,89,125,89,69,76,76,79,87,143,143
	.DB 143,143,143,143,80,82,69,83,83,143,65,78,89,143,75,69,89,143,84,79,143,71,79,143,66,65,67,75,143,143,143,143
	.DB 128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,175,191,159,207,128,191,159,207,128,175,191,159,207,128,175,191

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DELAY VALUES SHOWN ON LEFT WILL RESULT IN THE FOLLOWING NOTE
; NOTE THESE ARE FOR THE COCO2 RUNNING AT 0.89MHZ COCO3 VALUES
; WILL BE DIFFERENT BECAUSE OF THE FASTER CLOCK SPEED
; 60 = A#
; 64 = A (880 HZ)
; 69 = G# (830 HZ)
; 73 = G (783 HZ)
; 78 = F# (749 HZ)
; 83 = F (698 HZ)
; 88 = E (659 HZ)
; 94 = D# (622 HZ)
; 100 = D (587 HZ)
; 106 = C# (55 4HZ)
; 110 = Middle C (523 HZ)
; 120 = B
; 127 = A#
; 135 = A (440HZ)
;
; TO GET THE OUTER LOOP TIME (THE TONE LENGHT), JUST USE
; THE FREQUENCY FROM THE TABLE ABOVE (WILL REQUIRE 16 BITS)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FILL_FREQ .DW 0x0000	
FREQ .DB 0x01	
SOUND_LENGTH .DB 0x00
TONE_LENGTH .DW 0x00FF
VARIABLE_AREA_END 
	END START
	